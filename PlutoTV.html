<!DOCTYPE html>
<html>
<head>
    <title>North American TV Guide</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #333;
            color: white;
            padding: 10px 20px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .source-section {
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .folder-section {
            margin: 15px 0;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .folder-section h3 {
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
            color: #333;
            font-size: 18px;
        }
        
        .channels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }
        
        .channel-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .channel-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .channel-logo {
            width: 100px;
            height: 60px;
            object-fit: contain;
            margin-bottom: 10px;
        }
        
        .channel-name {
            font-weight: bold;
            margin: 5px 0;
            font-size: 14px;
            max-width: 180px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .channel-status {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-top: 5px;
        }
        
        .status-online {
            background: #4CAF50;
            color: white;
        }
        
        .status-offline {
            background: #f44336;
            color: white;
        }
        
        .status-loading {
            background: #2196F3;
            color: white;
        }
        
        #video-player {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
        }
        
        #video-container {
            position: relative;
            width: 80%;
            max-width: 1200px;
            margin: 40px auto;
        }
        
        #player-wrapper {
            position: relative;
            background: black;
        }
        
        #video-element {
            width: 100%;
            height: calc(100vh - 100px);
            display: none;
        }
        
        #loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            display: none;
        }
        
        #close-player {
            position: absolute;
            top: -30px;
            right: 0;
            background: white;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="status-bar">
        <div>Channels: <span id="total-channels">0</span> (<span id="working-channels">0</span> working)</div>
        <div id="verification-status">Loading channels...</div>
    </div>
    
    <div id="channels-container" style="margin-top: 60px;"></div>
    
    <div id="video-player">
        <div id="video-container">
            <button id="close-player">Close</button>
            <div id="player-wrapper" style="position: relative; background: black;">
                <video id="video-element" controls style="width: 100%; height: calc(100vh - 100px); display: none;"></video>
                <div id="loading-message" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 20px; display: none;"></div>
            </div>
        </div>
    </div>
    
    <div class="loading-overlay" id="loading-overlay">
        <div class="spinner"></div>
    </div>
    
    <script>
        let channels = {};
        let statusCheckInterval;
        let currentHls = null;

        // Load channels on page load
        window.addEventListener('DOMContentLoaded', () => {
            document.addEventListener('keydown', handleKeyPress);
            loadChannels();
            startStatusCheck();
        });
        
        function handleKeyPress(e) {
            if (e.key === 'Escape') {
                closePlayer();
            }
        }
        
        async function loadChannels() {
            try {
                const response = await fetch('/channels');
                channels = await response.json();
                displayChannels();
            } catch (error) {
                console.error('Error loading channels:', error);
                document.getElementById('verification-status').textContent = 'Error loading channels';
            }
        }
        
        function displayChannels() {
            const container = document.getElementById('channels-container');
            container.innerHTML = '';
            
            for (const [sourceName, sourceChannels] of Object.entries(channels)) {
                if (!sourceChannels || sourceChannels.length === 0) continue;
                
                const sourceSection = document.createElement('div');
                sourceSection.className = 'source-section';
                sourceSection.innerHTML = `<h2>${sourceName}</h2>`;
                
                // Group channels by folder
                const folderGroups = {};
                sourceChannels.forEach(channel => {
                    const folder = channel.folder || 'General';
                    if (!folderGroups[folder]) {
                        folderGroups[folder] = [];
                    }
                    folderGroups[folder].push(channel);
                });
                
                // Sort folders alphabetically, but keep 'General' at the end
                const sortedFolders = Object.keys(folderGroups).sort((a, b) => {
                    if (a === 'General') return 1;
                    if (b === 'General') return -1;
                    return a.localeCompare(b);
                });
                
                // Create folder sections
                sortedFolders.forEach(folder => {
                    const folderChannels = folderGroups[folder];
                    
                    // Count verified channels in this folder
                    const verifiedChannels = folderChannels.filter(ch => ch.verified);
                    
                    const folderSection = document.createElement('div');
                    folderSection.className = 'folder-section';
                    folderSection.innerHTML = `
                        <h3>${folder} (${verifiedChannels.length} working / ${folderChannels.length} total)</h3>
                    `;
                    
                    const channelsGrid = document.createElement('div');
                    channelsGrid.className = 'channels-grid';
                    
                    // Sort channels by name
                    folderChannels.sort((a, b) => a.name.localeCompare(b.name));
                    
                    // Show all channels, but mark unverified ones
                    folderChannels.forEach(channel => {
                        const card = createChannelCard(channel);
                        channelsGrid.appendChild(card);
                    });
                    
                    folderSection.appendChild(channelsGrid);
                    sourceSection.appendChild(folderSection);
                });
                
                container.appendChild(sourceSection);
            }
            
            document.getElementById('loading-overlay').style.display = 'none';
        }
        
        function createChannelCard(channel) {
            const card = document.createElement('div');
            card.className = 'channel-card';
            card.onclick = () => playChannel(channel);
            
            let logoHtml = '';
            if (channel.logo) {
                logoHtml = `<img src="${channel.logo}" class="channel-logo" onerror="this.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='" alt="${channel.name}">`;
            }
            
            const status = channel.verified ? 'status-online' : (channel.last_checked ? 'status-offline' : 'status-loading');
            const statusText = channel.verified ? 'Online' : (channel.last_checked ? 'Offline' : 'Checking...');
            
            card.innerHTML = `
                ${logoHtml}
                <div class="channel-name">${channel.name}</div>
                <div class="channel-status ${status}">${statusText}</div>
            `;
            
            return card;
        }
        
        function showMessage(msg) {
            const loadingMsg = document.getElementById('loading-message');
            loadingMsg.textContent = msg;
            loadingMsg.style.display = 'block';
        }

        function hideMessage() {
            document.getElementById('loading-message').style.display = 'none';
        }

        function showVideo() {
            document.getElementById('video-element').style.display = 'block';
        }

        function hideVideo() {
            document.getElementById('video-element').style.display = 'none';
        }

        function closePlayer() {
            if (currentHls) {
                currentHls.destroy();
                currentHls = null;
            }
            const video = document.getElementById('video-element');
            video.pause();
            video.src = '';
            video.load();
            hideVideo();
            hideMessage();
        }

        function playChannel(channel) {
            if (!channel.verified) {
                alert('This channel is currently offline or still being verified.');
                return;
            }

            // Clean up previous player
            closePlayer();
            
            const video = document.getElementById('video-element');
            showMessage('Loading stream...');
            
            // Use proxy to avoid CORS issues
            const proxyUrl = `/proxy/${encodeURIComponent(channel.url)}`;
            console.log('Playing URL:', proxyUrl);
            
            // Set up error handling
            video.onerror = (e) => {
                console.error('Video error:', video.error, e);
                showMessage('Error: Stream not available');
                setTimeout(closePlayer, 2000);
            };
            
            // Set up loading handlers
            video.onloadstart = () => {
                console.log('Stream loading started');
                showMessage('Loading stream...');
            };
            
            video.oncanplay = () => {
                console.log('Stream can play');
                hideMessage();
                showVideo();
            };
            
            video.onplaying = () => {
                console.log('Stream is playing');
                hideMessage();
                showVideo();
            };
            
            // Set up stalled/waiting handlers
            video.onstalled = () => {
                console.log('Stream stalled');
                showMessage('Stream stalled, reconnecting...');
            };
            
            video.onwaiting = () => {
                console.log('Stream buffering');
                showMessage('Buffering...');
            };

            // Check if it's an HLS stream
            if (channel.url.toLowerCase().includes('.m3u8')) {
                console.log('Detected HLS stream');
                if (Hls.isSupported()) {
                    console.log('HLS.js is supported');
                    if (currentHls) {
                        currentHls.destroy();
                    }
                    
                    currentHls = new Hls({
                        debug: true,
                        maxBufferLength: 30,
                        maxMaxBufferLength: 60,
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90
                    });

                    currentHls.on(Hls.Events.ERROR, function(event, data) {
                        console.error('HLS error:', event, data);
                        if (data.fatal) {
                            switch(data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    showMessage('Network error, retrying...');
                                    currentHls.startLoad();
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    showMessage('Media error, recovering...');
                                    currentHls.recoverMediaError();
                                    break;
                                default:
                                    showMessage('Stream error, closing...');
                                    setTimeout(closePlayer, 2000);
                                    break;
                            }
                        }
                    });

                    currentHls.loadSource(proxyUrl);
                    currentHls.attachMedia(video);
                    
                    currentHls.on(Hls.Events.MANIFEST_PARSED, () => {
                        console.log('HLS manifest parsed');
                        video.play().catch(error => {
                            console.error('Error playing HLS:', error);
                            showMessage('Error: Could not start playback');
                            setTimeout(closePlayer, 2000);
                        });
                    });
                } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    console.log('Using native HLS support');
                    video.src = proxyUrl;
                    showVideo();
                    video.play().catch(error => {
                        console.error('Error playing HLS:', error);
                        showMessage('Error: Could not start playback');
                        setTimeout(closePlayer, 2000);
                    });
                } else {
                    showMessage('HLS playback not supported in your browser');
                    setTimeout(closePlayer, 2000);
                }
            } else {
                console.log('Regular video stream');
                video.src = proxyUrl;
                showVideo();
                video.play().catch(error => {
                    console.error('Error playing video:', error);
                    showMessage('Error: Could not start playback');
                    setTimeout(closePlayer, 2000);
                });
            }
            
            // Set up timeout for initial load
            const loadTimeout = setTimeout(() => {
                if (!video.readyState) {
                    console.log('Stream load timeout');
                    showMessage('Error: Stream took too long to load');
                    setTimeout(closePlayer, 2000);
                }
            }, 15000);
            
            // Clear timeout when video starts playing
            video.onplaying = () => {
                console.log('Stream started playing, clearing timeout');
                clearTimeout(loadTimeout);
                hideMessage();
                showVideo();
            };
        }
        
        document.getElementById('close-player').onclick = closePlayer;
        
        async function checkStatus() {
            try {
                const response = await fetch('/status');
                const status = await response.json();
                
                // Update total and working channels
                const totalChannels = status.total || 0;
                const workingChannels = status.working || 0;
                
                document.getElementById('total-channels').textContent = totalChannels;
                document.getElementById('working-channels').textContent = workingChannels;
                
                const statusText = status.verifying ? 'Verifying channels...' : 'Verification complete';
                document.getElementById('verification-status').textContent = statusText;
                
                if (!status.verifying) {
                    loadChannels();
                    clearInterval(statusCheckInterval);
                }
            } catch (error) {
                console.error('Error checking status:', error);
            }
        }
        
        function startStatusCheck() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
            }
            statusCheckInterval = setInterval(checkStatus, 5000);
            checkStatus();
        }
    </script>
</body>
</html>

